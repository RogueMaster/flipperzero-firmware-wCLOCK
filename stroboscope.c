/*
My first flipper application
Simple stroboscope which can be used to measure the speed of a rotating object.

Parts of the code are taken from
https://github.com/instantiator/flipper-zero-tutorial-app/
https://github.com/flipperdevices/flipperzero-firmware/blob/dev/applications/examples/example_thermo/example_thermo.c

*/

#include <furi.h>

#include <furi_hal_power.h>
#include <furi_hal_pwm.h>

#include <gui/gui.h>
#include <gui/view_port.h>
#include <gui/icon_i.h>

#define TAG "stroboscope"

/* generated by fbt from .png files in images folder */
#include <stroboscope_icons.h>

#define STROBOSCOPE_PIN (FuriHalPwmOutputIdLptim2PA4)

/** the app context struct */
typedef struct {
    Gui* gui;
    ViewPort* view_port;
    FuriMessageQueue* event_queue;
    int frequency;
} StroboscopeAppContext;

/* Draw the GUI of the application. The screen is completely redrawn during each call. */

static void stroboscope_app_draw_callback(Canvas* canvas, void* ctx){
    StroboscopeAppContext* context = ctx;
    char text_store[32];
    const size_t middle_x = canvas_width(canvas) /2U;

    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str_aligned(canvas, middle_x, 12, AlignCenter, AlignBottom, "Stroboscope");
    canvas_draw_line(canvas, 0, 16, 128, 16);

    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str_aligned(canvas, middle_x, 24, AlignCenter, AlignBottom, "Speed: 0 RPM");

    snprintf(text_store, sizeof(text_store), "Frequency: %i Hz on pin %i", context->frequency, 4);
    canvas_draw_str_aligned(canvas, middle_x, 42, AlignCenter, AlignBottom, text_store);
}

static void stroboscope_app_input_callback(InputEvent* event, void* ctx){
    StroboscopeAppContext* context = ctx;
    furi_message_queue_put(context->event_queue, event, FuriWaitForever);
}

static void stroboscope_app_run(StroboscopeAppContext* context){
    furi_hal_power_enable_otg();

    // Set the pin as output to control the PWM to the LED

    furi_hal_pwm_start(STROBOSCOPE_PIN, 4, 50);

    view_port_enabled_set(context->view_port, true);

    for (bool is_running = true; is_running;) {
        InputEvent event;

        const FuriStatus status = furi_message_queue_get(context->event_queue, &event, FuriWaitForever);

        if((status != FuriStatusOk) || (event.type != InputTypeShort)) {
            continue;
        }

        if(event.key == InputKeyBack) {
            is_running = false;
        }
    }

    furi_hal_pwm_stop(STROBOSCOPE_PIN);

    furi_hal_power_disable_otg();
}

static StroboscopeAppContext* stroboscope_app_context_alloc(void){
    StroboscopeAppContext* context = malloc(sizeof(StroboscopeAppContext));

    context->view_port = view_port_alloc();
    view_port_draw_callback_set(context->view_port, stroboscope_app_draw_callback, context);
    view_port_input_callback_set(context->view_port, stroboscope_app_input_callback, context);

    context->event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    context->gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(context->gui, context->view_port, GuiLayerFullscreen);

    return context;
}

static void stroboscope_app_context_free(StroboscopeAppContext* context){
    view_port_enabled_set(context->view_port, false);
    gui_remove_view_port(context->gui, context->view_port);

    furi_message_queue_free(context->event_queue);
    view_port_free(context->view_port);

    furi_record_close(RECORD_GUI);
}

void stroboscope_app_set_log_level() {
#ifdef FURI_DEBUG
    furi_log_set_level(FuriLogLevelTrace);
#else
    furi_log_set_level(FuriLogLevelInfo);
#endif
}

int32_t stroboscope_app(void* p) {
    UNUSED(p);
    stroboscope_app_set_log_level();

    FURI_LOG_I(TAG, "Test app starting...");

    StroboscopeAppContext* context = stroboscope_app_context_alloc();

    stroboscope_app_run(context);

    stroboscope_app_context_free(context);

    return 0;
}
